import secrets
import random

def miller_rabin_test(n, k=5):
    if n <= 1:
        return False
    if n <= 3:
        return True

    # Write n as (2^r) * d + 1
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2

    # Witness loop
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n)  # Compute a^d % n

        if x == 1 or x == n - 1:
            continue

        for _ in range(r - 1):
            x = pow(x, 2, n)  # Compute (x^2) % n
            if x == n - 1:
                break
        else:
            return False  # n is definitely composite

    return True  # n is probably prime

def generate_strong_prime():
    while True:
    # Specify the number of bits (1024 in this case)
        num_bits = 1024

        # Generate random bits
        random_bits = secrets.randbits(num_bits - 2)  

        # Set the highest and lowest bits to 1
        random_number = (1 << (num_bits - 1)) | random_bits | 1  

        # Convert the random number to its binary representation
        random_binary = bin(random_number)[2:]

        # Ensure the binary representation has exactly 1024 bits (pad with leading zeros if necessary)
        random_binary = random_binary.zfill(num_bits)
        random_num=int(random_binary, 2)
        random_num2=random_num - 1 // 2
        is1_prime = miller_rabin_test(random_num)
        is2_prime = miller_rabin_test(random_num2)
        if is1_prime & is2_prime: 
            return random_num , random_binary


def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    
    gcd, x1, y1 = extended_gcd(b, a % b)
    
    x = y1
    y = x1 - (a // b) * y1
    
    return gcd, x, y

prime,bits=generate_strong_prime()
print("Prime No: "+str(prime) )
# print("Prime bits: "+str(bits) )

p=98413552576193920343189105965109670374361411876793471544176163080830156567546462310733804769874761097039629004080686728453502977350822957963127456711357790479871099110231228241516353504477175641053884237056416876290699990834976108232400288614833069641057736922445475600963987790757920094050474227880838564209
q= 126808458983799494505344922913760754939404614194977234102555524000940219852057201570629170006763287484204278335759904806841071273014562151481411352730282274926239904038107193465173098483495525747659883698418128676474445804694867361131126245542026971147052240357403541630386719217293415700204707491391428105897
n=(p-1)*(q-1)
print(f"p.q : {p*q}")
print(f"phi(n) : {n}")
print(f"d : {extended_gcd(65537,n)}")

def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, x, y = extended_gcd(b % a, a)
        return (g, y - (b // a) * x, x)

def calculate_d(e, phi_n):
    gcd, x, y = extended_gcd(e, phi_n)
    if gcd != 1:
        raise ValueError("The modular inverse does not exist.")
    else:
        return x % phi_n


e = 65537  # Public exponent
phi_n = n

# Calculate d
d = calculate_d(e, phi_n)
print("Private exponent (d):", d)
#d=10265446709349286126675719586746207277848990220630137173132300953010272418328731128503732650965857817550785080373951663657042578195735478105817256069865346494830532260185980215051491718565119245596494534419848325967628535692440029319009698705919550833495983517865469144946889917420108849374586340922862303467173703887190601178838399848331781507630046451731548750476500309425806876176463156236272781148953689986772204340774455649116893153805111833253152385075015659371611094309961046618788270301148136140611565933363411325124325196186558403640436340531908421655581884181433993894703928351665747485968688882063617355649


def encrypt(message, e, n):
    # Convert the message to an integer (using a suitable encoding)
    message_int = int.from_bytes(message.encode('utf-8'), byteorder='big')
    
    # Encrypt the message using the formula c = m^e mod n
    encrypted_message = pow(message_int, e, n)
    
    return encrypted_message

# RSA parameters (replace with your provided values)
e = 65537
n = 12479670945308281824629405749625965726843185221195668625193782254492463660613442133386802328856951970706668678930562061642612540525958857122575924447694544755638364516793273578694273920117275779529530547817128860467463157240450429454820876367394119775451710694139183649342119581479190370095202378546469546501331958023261387049631820880056224200482111836736604229918715971317039167233324301812999793455503877675886545041918825223105029399244526147414299848612489112285802265976287690145271634382866789541847014639639673602157137863319609150407197840421856279450334651148751049505687299272480616489276977027361886040473

# Message to encrypt
message = "ejecting"

# Encrypt the message
encrypted_message = encrypt(message, e, n)

# Print the encrypted message (as a large integer)
print("Encrypted Message:", encrypted_message)


def decrypt(ciphertext, d, n):
    # Decrypt the ciphertext using the formula m = c^d mod n
    decrypted_message = pow(ciphertext, d, n)
    
    # Convert the decrypted integer back to a message (using the original encoding)
    decrypted_message = decrypted_message.to_bytes((decrypted_message.bit_length() + 7) // 8, byteorder='big').decode('utf-8')
    
    return decrypted_message

# RSA parameters
d = 10265446709349286126675719586746207277848990220630137173132300953010272418328731128503732650965857817550785080373951663657042578195735478105817256069865346494830532260185980215051491718565119245596494534419848325967628535692440029319009698705919550833495983517865469144946889917420108849374586340922862303467173703887190601178838399848331781507630046451731548750476500309425806876176463156236272781148953689986772204340774455649116893153805111833253152385075015659371611094309961046618788270301148136140611565933363411325124325196186558403640436340531908421655581884181433993894703928351665747485968688882063617355649  # Replace with your actual private exponent
# n = 12479670945308281824629405749625965726843185221195668625193782254492463660613442133386802328856951970706668678930562061642612540525958857122575924447694544755638364516793273578694273920117275779529530547817128860467463157240450429454820876367394119775451710694139183649342119581479190370095202378546469546501331958023261387049631820880056224200482111836736604229918715971317039167233324301812999793455503877675886545041918825223105029399244526147414299848612489112285802265976287690145271634382866789541847014639639673602157137863319609150407197840421856279450334651148751049505687299272480616489276977027361886040473

# Ciphertext to decrypt 
ciphertext = 4984639341278969264736168300745092086115618261758633548997055171644398873257230771596198162988260165870527698663182470019195548236550025163836083955666454292362237900668874694488071095142573915680008530715593044716063275930122483487458050171974699611828370312000202178095165299999684863225341372264382912292082661052773152597647014257788819028062212354072729733698891566428107191898698072585548213591734921223844230986523870968551908571820519162396817490261291003210090872683843749657694413588590239874621160158451159155853567259593900181385154779361828804361515337077054688636286176880913406013390948375436805136155

# Decrypt the ciphertext
decrypted_message = decrypt(ciphertext, d, n)

# Print the decrypted message
print("Decrypted Message:", decrypted_message)

